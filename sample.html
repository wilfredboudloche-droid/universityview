<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Types Matching Activity</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            color: #333;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            padding: 30px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #1a2a6c;
        }

        h1 {
            color: #1a2a6c;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #b21f1f;
            font-size: 1.2em;
            margin-bottom: 15px;
        }

        .instructions {
            background-color: #e3f2fd;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 25px;
            border-left: 5px solid #1a2a6c;
        }

        .instructions h2 {
            color: #1a2a6c;
            margin-bottom: 10px;
        }

        .game-area {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 768px) {
            .game-area {
                flex-direction: column;
            }
        }

        .terms-column, .definitions-column {
            flex: 1;
            min-width: 300px;
        }

        .column-title {
            text-align: center;
            padding: 15px;
            background: #1a2a6c;
            color: white;
            border-radius: 10px 10px 0 0;
            font-weight: bold;
            font-size: 1.2em;
        }

        .drop-zone {
            min-height: 400px;
            padding: 20px;
            background: #f5f5f5;
            border-radius: 0 0 10px 10px;
            border: 2px dashed #1a2a6c;
        }

        .term, .definition {
            padding: 15px;
            margin: 10px;
            border-radius: 8px;
            cursor: grab;
            text-align: center;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .term {
            background: linear-gradient(to right, #4a90e2, #63b3ed);
            color: white;
            border: 2px solid #1a2a6c;
        }

        .definition {
            background: white;
            border: 2px solid #b21f1f;
            color: #333;
        }

        .term:hover, .definition:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .term:active, .definition:active {
            cursor: grabbing;
        }

        .drop-target {
            background: #e3f2fd;
            border: 2px dashed #4a90e2;
            min-height: 80px;
            margin: 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            text-align: center;
        }

        .matched {
            background: #d4edda;
            border: 2px solid #28a745;
        }

        .matched .term {
            background: #28a745;
            cursor: default;
        }

        .matched .definition {
            background: #d4edda;
            border: 2px solid #28a745;
        }

        .feedback {
            padding: 15px;
            margin: 20px 0;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            display: none;
        }

        .correct {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .incorrect {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        button {
            padding: 12px 25px;
            border: none;
            border-radius: 30px;
            background: #1a2a6c;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
        }

        button:hover {
            background: #b21f1f;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .score-container {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 10px;
            font-weight: bold;
            font-size: 1.2em;
        }

        .score {
            color: #1a2a6c;
            font-size: 1.5em;
        }

        .progress-bar {
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress {
            height: 100%;
            background: linear-gradient(to right, #4a90e2, #63b3ed);
            border-radius: 10px;
            width: 0%;
            transition: width 0.5s ease;
        }

        footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            color: #666;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Network Types and Their Purposes</h1>
            <div class="subtitle">Comparing Local Networking Hardware</div>
            <div class="progress-bar">
                <div class="progress" id="progress"></div>
            </div>
        </header>

        <div class="instructions">
            <h2>Activity Instructions</h2>
            <p>Match each network type with its correct description by dragging terms to their definitions. You'll receive immediate feedback after each match. Complete all matches to finish the activity.</p>
        </div>

        <div class="score-container">
            Matches: <span class="score" id="score">0</span> / 6
        </div>

        <div class="game-area">
            <div class="terms-column">
                <div class="column-title">Network Types</div>
                <div class="drop-zone" id="terms-zone">
                    <!-- Terms will be populated by JavaScript -->
                </div>
            </div>

            <div class="definitions-column">
                <div class="column-title">Definitions</div>
                <div class="drop-zone" id="definitions-zone">
                    <!-- Definitions will be populated by JavaScript -->
                </div>
            </div>
        </div>

        <div class="feedback" id="feedback"></div>

        <div class="controls">
            <button id="check-btn">Check Answers</button>
            <button id="reset-btn">Reset Activity</button>
        </div>

        <footer>
            <p>Computer Architecture - A+ Core 1 Domain 2.7 | Professional IT Certification</p>
        </footer>
    </div>

    <script>
        // Network terms and definitions
        const terms = [
            { id: 1, text: "Local Area Network (LAN)" },
            { id: 2, text: "Wide Area Network (WAN)" },
            { id: 3, text: "Metropolitan Area Network (MAN)" },
            { id: 4, text: "Personal Area Network (PAN)" },
            { id: 5, text: "Storage Area Network (SAN)" },
            { id: 6, text: "SOHO Network" }
        ];

        const definitions = [
            { id: 1, text: "Covers a small geographic area like a home, office, or building. Uses Ethernet or Wi-Fi for connectivity." },
            { id: 2, text: "Spans large geographical areas like cities or countries. Connects multiple LANs using leased lines or satellites." },
            { id: 3, text: "Covers a city or large campus. Larger than LAN but smaller than WAN. Often used by city governments or universities." },
            { id: 4, text: "Connects devices within an individual's workspace. Uses Bluetooth or USB for short-range communication." },
            { id: 5, text: "Dedicated high-speed network for connecting storage devices to servers. Uses Fibre Channel or iSCSI protocols." },
            { id: 6, text: "Small office/home office network with minimal infrastructure. Typically uses a single router for all connectivity." }
        ];

        // Correct matches
        const correctMatches = {
            1: 1, // LAN -> definition 1
            2: 2, // WAN -> definition 2
            3: 3, // MAN -> definition 3
            4: 4, // PAN -> definition 4
            5: 5, // SAN -> definition 5
            6: 6  // SOHO -> definition 6
        };

        // Game state
        let matches = {};
        let score = 0;

        // DOM elements
        const termsZone = document.getElementById('terms-zone');
        const definitionsZone = document.getElementById('definitions-zone');
        const feedbackEl = document.getElementById('feedback');
        const scoreEl = document.getElementById('score');
        const progressEl = document.getElementById('progress');
        const checkBtn = document.getElementById('check-btn');
        const resetBtn = document.getElementById('reset-btn');

        // Initialize the game
        function initGame() {
            // Clear zones
            termsZone.innerHTML = '';
            definitionsZone.innerHTML = '';
            matches = {};
            score = 0;
            updateScore();
            updateProgress();
            feedbackEl.style.display = 'none';

            // Shuffle and populate terms
            shuffleArray(terms).forEach(term => {
                const termEl = createTermElement(term);
                termsZone.appendChild(termEl);
            });

            // Shuffle and populate definitions
            shuffleArray(definitions).forEach(def => {
                const defEl = createDefinitionElement(def);
                definitionsZone.appendChild(defEl);
            });

            // Add event listeners to buttons
            checkBtn.addEventListener('click', checkAnswers);
            resetBtn.addEventListener('click', initGame);
        }

        // Create term element
        function createTermElement(term) {
            const el = document.createElement('div');
            el.className = 'term';
            el.textContent = term.text;
            el.draggable = true;
            el.dataset.id = term.id;

            el.addEventListener('dragstart', handleDragStart);
            el.addEventListener('dragend', handleDragEnd);

            return el;
        }

        // Create definition element
        function createDefinitionElement(def) {
            const el = document.createElement('div');
            el.className = 'definition';
            el.textContent = def.text;
            el.draggable = false;
            el.dataset.id = def.id;

            el.addEventListener('dragover', handleDragOver);
            el.addEventListener('dragenter', handleDragEnter);
            el.addEventListener('dragleave', handleDragLeave);
            el.addEventListener('drop', handleDrop);

            return el;
        }

        // Drag and drop handlers
        function handleDragStart(e) {
            e.dataTransfer.setData('text/plain', e.target.dataset.id);
            e.target.classList.add('dragging');
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
        }

        function handleDragOver(e) {
            e.preventDefault();
        }

        function handleDragEnter(e) {
            e.preventDefault();
            e.target.classList.add('drop-target');
        }

        function handleDragLeave(e) {
            e.target.classList.remove('drop-target');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.target.classList.remove('drop-target');

            const termId = parseInt(e.dataTransfer.getData('text/plain'));
            const defId = parseInt(e.target.dataset.id);

            // Check if this is a correct match
            if (correctMatches[termId] === defId) {
                showFeedback('Correct! Well done.', true);
                createMatch(termId, defId, true);
            } else {
                showFeedback(`Incorrect. ${getTermText(termId)} is ${getDefinitionText(correctMatches[termId])}`, false);
                // Move term back to terms zone
                const termEl = document.querySelector(`.term[data-id="${termId}"]`);
                if (termEl) {
                    termsZone.appendChild(termEl);
                }
            }
        }

        // Create a match between term and definition
        function createMatch(termId, defId, isCorrect) {
            // Remove the term from the terms zone
            const termEl = document.querySelector(`.term[data-id="${termId}"]`);
            if (termEl) {
                termEl.remove();
            }

            // Remove the definition from the definitions zone
            const defEl = document.querySelector(`.definition[data-id="${defId}"]`);
            if (defEl) {
                defEl.remove();
            }

            // Create a matched container
            const matchedContainer = document.createElement('div');
            matchedContainer.className = `matched ${isCorrect ? 'correct' : 'incorrect'}`;

            // Add the term and definition to the container
            const termClone = createTermElement(terms.find(t => t.id === termId));
            termClone.draggable = false;
            matchedContainer.appendChild(termClone);

            const defClone = createDefinitionElement(definitions.find(d => d.id === defId));
            defClone.draggable = false;
            matchedContainer.appendChild(defClone);

            // Add to definitions zone
            definitionsZone.appendChild(matchedContainer);

            // Update matches and score
            matches[termId] = defId;
            if (isCorrect) {
                score++;
                updateScore();
                updateProgress();
            }

            // Check if game is complete
            if (Object.keys(matches).length === terms.length) {
                setTimeout(() => {
                    showFeedback(`Activity Complete! You matched all ${score} correctly.`, true);
                }, 1000);
            }
        }

        // Show feedback message
        function showFeedback(message, isCorrect) {
            feedbackEl.textContent = message;
            feedbackEl.className = `feedback ${isCorrect ? 'correct' : 'incorrect'}`;
            feedbackEl.style.display = 'block';

            // Hide feedback after 3 seconds
            setTimeout(() => {
                feedbackEl.style.display = 'none';
            }, 3000);
        }

        // Update score display
        function updateScore() {
            scoreEl.textContent = score;
        }

        // Update progress bar
        function updateProgress() {
            const progress = (Object.keys(matches).length / terms.length) * 100;
            progressEl.style.width = `${progress}%`;
        }

        // Check all answers
        function checkAnswers() {
            let correctCount = 0;

            // Check each match
            for (const termId in matches) {
                const defId = matches[termId];
                if (correctMatches[termId] == defId) {
                    correctCount++;
                }
            }

            showFeedback(`You have ${correctCount} out of ${terms.length} matches correct.`, correctCount === terms.length);
        }

        // Helper functions
        function getTermText(id) {
            return terms.find(t => t.id === id)?.text || '';
        }

        function getDefinitionText(id) {
            return definitions.find(d => d.id === id)?.text || '';
        }

        // Utility function to shuffle array
        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // Initialize the game when page loads
        window.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
